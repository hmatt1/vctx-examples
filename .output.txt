==== C:\Users\Matt\Projects\vctx\vctx-examples\components\bit.vctx ====
component Gate(out y: u8, out b: u7) {
    wire a: u8 = 25
    y := a
}


sim TestOr {
    // 2. Output wire
    wire a1: u8
    wire b1: u7

    Gate(a1, b1)

    cycle()
    
    assert(a1 == 25, "check1")
}


==== C:\Users\Matt\Projects\vctx\vctx-examples\components\foo.vctx ====
import src.utils.math as math

component MyFoo(
    in sw_input: u8, 
    out led_result: u8,
    out status_led: u1
) {
    wire current_op: u8 = 0
    wire ten: u8 = 11
 
    math.Alu(
        sw_input, 
        ten,
        current_op,
        led_result,
        status_led
    )
}

sim TestBenchName {
    wire sw_input1: u8 = 0
    wire led_result1: u8 = 16
    wire status_led1: u1 = 0

    wire status_led2: u18 = 16

    MyFoo(sw_input1, led_result1, status_led1)

    cycle(1)
    cycle(1)
    cycle(1)
    assert(status_led2 == 16, "blah!")
    assert((status_led2 + 2) == 14, "blah! 2")
    assert(led_result1 == 16, "LED is on!")
}

==== C:\Users\Matt\Projects\vctx\vctx-examples\components\or_1bit.vctx ====
component OrGate(in a: u1, in b: u1, out y: u1) {
    y := a | b 
    wire y2: u1 = a | b 
    /* y3: u1 = a | b  */
}

sim TestOr {
    // 1. Inputs driven with initial values
    wire a: u1 = 1
    wire b: u1 = 0

    // 2. Output wire
    wire x: u1

    // 3. Instantiate the component
    // Connect inputs 'a', 'b' and output 'y'
    OrGate(a, b, x)

    cycle()
    cycle()
    cycle()
    
    assert(x == 1, "assert 1 | 0 should result in 1")
    assert(x == 2, "on purpose error to test failure reporting")
    assert(x == 1, "assert 1 | 0 should result in 1")

}


==== C:\Users\Matt\Projects\vctx\vctx-examples\components\or_2bit.vctx ====
component OrGate1(in a: u2, in b: u2, out y: u2) {
    y := a | b
}

sim TestOr {
    // 1. Inputs driven with initial values
    wire a: u2 = 2
    wire b: u2 = 0
    
    // 2. Output wire
    wire x: u2

    // 3. Instantiate the component
    // Connect inputs 'a', 'b' and output 'y'
    OrGate1(a, b, x)

    cycle()
    cycle()
    
    assert(x == 2, "assert 2 | 0 should result in 2")

}


==== C:\Users\Matt\Projects\vctx\vctx-examples\control_flow\when.vctx ====



component Alu(
    in a: u8, 
    in b: u8, 
    in opcode: u8, 
    out y: u8, 
    out is_zero: u1
) {

    wire OP_ADD : u8 = 0
    wire OP_SUB : u8 = 1
    wire OP_AND : u8 = 2
    wire OP_OR  : u8 = 3

    when (opcode == OP_ADD) {
        y := (a + b) as u8
    }
    elsewhen (opcode == OP_SUB) {
        y := (a - b) as u8
    }
    elsewhen (opcode == OP_AND) {
        y := a & b
    }
    elsewhen (opcode == OP_OR) {
        y := a | b
    }

    is_zero := (y == 0)
}


sim TestAddBasic {
    wire a: u8 = 8
    wire b: u8 = 16
    wire op: u8 = 0
    wire y: u8
    wire is_zero: u1
    
    Alu(a, b, op, y, is_zero)
    
    cycle(1)
    assert(y == 24, "ADD: 8 + 16 should be 24")
    assert(is_zero == 0, "ADD: 24 is not zero")
}

sim TestAddZero {
    wire a: u8 = 0
    wire b: u8 = 0
    wire op: u8 = 0
    wire y: u8
    wire is_zero: u1
    
    Alu(a, b, op, y, is_zero)
    
    cycle(1)
    assert(y == 0, "ADD: 0 + 0 should be 0")
    assert(is_zero == 1, "ADD: is_zero flag should be 1")
}

sim TestAddOverflow {
    wire a: u8 = 255
    wire b: u8 = 1
    wire op: u8 = 0
    wire y: u8
    wire is_zero: u1
    
    Alu(a, b, op, y, is_zero)
    
    cycle(1)
    assert(y == 0, "ADD: 255 + 1 should wrap around to 0 in u8")
    assert(is_zero == 1, "ADD: wrap-around should set is_zero flag to 1")
}

sim TestSubBasic {
    wire a: u8 = 20
    wire b: u8 = 5
    wire op: u8 = 1
    wire y: u8
    wire is_zero: u1
    
    Alu(a, b, op, y, is_zero)
    
    cycle(1)
    assert(y == 15, "SUB: 20 - 5 should be 15")
    assert(is_zero == 0, "SUB: 15 is not zero")
}

sim TestSubZero {
    wire a: u8 = 10
    wire b: u8 = 10
    wire op: u8 = 1
    wire y: u8
    wire is_zero: u1
    
    Alu(a, b, op, y, is_zero)
    
    cycle(1)
    assert(y == 0, "SUB: 10 - 10 should be 0")
    assert(is_zero == 1, "SUB: is_zero flag should be 1")
}

sim TestSubUnderflow {
    wire a: u8 = 5
    wire b: u8 = 10
    wire op: u8 = 1
    wire y: u8
    wire is_zero: u1
    
    Alu(a, b, op, y, is_zero)
    
    cycle(1)
    assert(y == 251, "SUB: 5 - 10 should underflow to 251 in u8")
    assert(is_zero == 0, "SUB: 251 is not zero")
}


sim TestAndMutuallyExclusive {
    // Using binary literals to easily visualize alternating bits
    wire a: u8 = 0b1010_1010
    wire b: u8 = 0b0101_0101
    wire op: u8 = 2
    wire y: u8
    wire is_zero: u1
    
    Alu(a, b, op, y, is_zero)
    
    cycle(1)
    assert(y == 0, "AND: Alternating bits should mask to 0")
    assert(is_zero == 1, "AND: is_zero flag should be 1")
}

sim TestAndMask {
    // Using hex literals
    wire a: u8 = 0xFF
    wire b: u8 = 0x0F
    wire op: u8 = 2
    wire y: u8
    wire is_zero: u1
    
    Alu(a, b, op, y, is_zero)
    
    cycle(1)
    assert(y == 0x0F, "AND: 0xFF & 0x0F should be 0x0F")
    assert(is_zero == 0, "AND: 0x0F is not zero")
}

sim TestOrCombine {
    wire a: u8 = 0b1010_0000
    wire b: u8 = 0b0000_1010
    wire op: u8 = 3
    wire y: u8
    wire is_zero: u1
    
    Alu(a, b, op, y, is_zero)
    
    cycle(1)
    assert(y == 0b1010_1010, "OR: Bits should combine")
    assert(is_zero == 0, "OR: Result is not zero")
}

sim TestOrZero {
    wire a: u8 = 0
    wire b: u8 = 0
    wire op: u8 = 3
    wire y: u8
    wire is_zero: u1
    
    Alu(a, b, op, y, is_zero)
    
    cycle(1)
    assert(y == 0, "OR: 0 | 0 should be 0")
    assert(is_zero == 1, "OR: is_zero flag should be 1")
}

sim TestInvalidOpcode {
    wire a: u8 = 255
    wire b: u8 = 255
    wire op: u8 = 99 
    wire y: u8
    wire is_zero: u1
    
    Alu(a, b, op, y, is_zero)
    
    cycle(1)
    assert(y == 0, "INVALID OPCODE: Output should default to 0")
    assert(is_zero == 1, "INVALID OPCODE: is_zero flag should be 1")
}

==== C:\Users\Matt\Projects\vctx\vctx-examples\imports\foo.vctx ====
import imports.utils.constant as c

component MyConstOne(
    out one: u1
) {
    c.Constant1(one)
}

sim TestConstant1 {
    wire one: u1

    MyConstOne(one)

    cycle(1)
    assert(one == 1, "Constant1 should output 1")
}

==== C:\Users\Matt\Projects\vctx\vctx-examples\imports\utils\constant.vctx ====

component Constant1(
    out one: u1
) {
    one := 1
}

==== C:\Users\Matt\Projects\vctx\vctx-examples\literals\boolean.vctx ====
sim TestBoolTrue {
    wire val: bool = true
    assert(val == true, "Boolean true assertion")
}

sim TestBoolFalse {
    wire val: bool = false
    assert(val == false, "Boolean false assertion")
}

==== C:\Users\Matt\Projects\vctx\vctx-examples\literals\signed_negative_binary.vctx ====
sim TestNegativeHexSmall {
    // -0x01 is the strict way to define -1 in hex
    wire val: s8 = -0x01
    assert(val == -1, "Negative hex (-0x01) assertion")
}

sim TestNegativeHex {
    // -0xA equals -10
    wire val: s8 = -0xA
    assert(val == -10, "Negative hex (-0xA) assertion")
}

sim TestNegativeBinary {
    // -0b101 equals -5
    wire val: s8 = -0b101
    assert(val == -5, "Negative binary (-0b101) assertion")
}

sim TestNegativeBinaryLarge {
    // -0b1000_0000 equals -128 (Min s8)
    wire val: s8 = -0b1000_0000
    assert(val == -128, "Large negative binary (-128) assertion")
}

sim TestNegativeHexLarge {
    // -0xFF equals -255. 
    // This requires s16, because -255 is too small for s8 (-128 min).
    wire val: s16 = -0xFF
    assert(val == -255, "Large negative hex (-0xFF) assertion")
}

==== C:\Users\Matt\Projects\vctx\vctx-examples\literals\signed_negative.vctx ====
sim TestS8Negative {
    // -1 is valid for s8
    wire val: s8 = -1
    assert(val == -1, "s8 (-1) assertion")
}

sim TestS8Min {
    // Testing minimum value for 8-bit signed (-128)
    wire val: s8 = -128
    assert(val == -128, "s8 min value (-128) assertion")
}

sim TestS16Negative {
    // Testing arbitrary negative number
    wire val: s16 = -12345
    assert(val == -12345, "s16 (-12345) assertion")
}

sim TestS32Negative {
    wire val: s32 = -2000000
    assert(val == -2000000, "s32 large negative assertion")
}

sim TestS64Negative {
    wire val: s64 = -9000000000000
    assert(val == -9000000000000, "s64 large negative assertion")
}

==== C:\Users\Matt\Projects\vctx\vctx-examples\literals\signed_positive.vctx ====
sim TestS8 {
    wire val: s8 = 127
    assert(val == 127, "s8 max value assertion")
}

sim TestS16 {
    wire val: s16 = 32000
    assert(val == 32000, "s16 value assertion")
}

sim TestSArbitrary {
    // Testing non-standard signed width (s5 max is 15)
    wire val: s5 = 15
    assert(val == 15, "s5 (arbitrary width) assertion")
}

==== C:\Users\Matt\Projects\vctx\vctx-examples\literals\underscores_formatting.vctx ====
sim TestHexLiteral {
    // 0xFF = 255. Valid for u8.
    wire val: u8 = 0xFF
    assert(val == 255, "Hex literal (0xFF) assertion")
}

sim TestBinaryLiteral {
    // 0b1010 = 10
    wire val: u4 = 0b1010
    assert(val == 10, "Binary literal (0b1010) assertion")
}

sim TestSeparatorLiteral {
    // Underscores in numbers (1_000)
    wire val: u16 = 1_000
    assert(val == 1000, "Decimal separator (1_000) assertion")
}

sim TestHexSeparator {
    // Underscores in Hex (0xAB_CD)
    wire val: u16 = 0xAB_CD
    assert(val == 43981, "Hex separator (0xAB_CD) assertion")
}

==== C:\Users\Matt\Projects\vctx\vctx-examples\literals\unsigned.vctx ====
sim TestU1 {
    // Single bit unsigned (0 or 1)
    wire val: u1 = 1
    assert(val == 1, "u1 assertion")
}

sim TestU8 {
    // Standard byte
    wire val: u8 = 255
    assert(val == 255, "u8 max value assertion")
}

sim TestU8U4 {
    // Standard byte
    wire val: u8 = 9
    assert(val == 9, "u8 max value assertion")
}


sim TestU16 {
    // 16-bit word
    wire val: u16 = 65535
    assert(val == 65535, "u16 max value assertion")
}

sim TestU32 {
    // 32-bit word
    wire val: u32 = 1000000
    assert(val == 1000000, "u32 value assertion")
}

sim TestU64 {
    // 64-bit word
    wire val: u64 = 1234567890123
    assert(val == 1234567890123, "u64 value assertion")
}

sim TestArbitraryWidth {
    // Testing non-standard width (u5 max is 31)
    wire val: u5 = 31
    assert(val == 31, "u5 (arbitrary width) assertion")
}

==== C:\Users\Matt\Projects\vctx\vctx-examples\operators\addition.vctx ====
sim TestAddUnsigned {
    wire a: u8 = 10
    wire b: u8 = 20
    wire c : u8 = 30
    wire max: u8 = 255
    
    assert(a + b == c, "10 + 20 = 30")
    
    // Test Overflow (Wrap around)
    // 255 + 1 = 0
    wire d: u8 = 1
    wire e : u8 = 0
    wire f : u8 = max + d
    assert(f == e, "u8 overflow wraps to 0")
    assert((max + d) as u8 == e, "u8 overflow wraps to 0")
}

/* sim TestAddSigned {
    wire a: s8 = 10
    wire b: s8 = -20

    
    
    assert(a + b == -10, "10 + (-20) = -10")
    
    // Test Negative Addition
    wire c: s8 = -5
    wire d: s8 = -5
    assert(c + d == -10, "-5 + (-5) = -10")
} */

==== C:\Users\Matt\Projects\vctx\vctx-examples\operators\arrays_and_slicing.vctx ====
// ==========================================
// 1. Single Bit Indexing
// ==========================================

sim TestBitIndexingUnsigned {
    wire data: u8 = 0b1010_0101
    
    assert(data[0] == 1, "Bit 0 should be 1")
    assert(data[1] == 0, "Bit 1 should be 0")
    assert(data[2] == 1, "Bit 2 should be 1")
    assert(data[7] == 1, "Bit 7 (MSB) should be 1")
}

sim TestBitIndexingSigned {
    wire data: s8 = -2
    
    assert(data[0] == 0, "Bit 0 of -2 should be 0")
    assert(data[1] == 1, "Bit 1 of -2 should be 1")
    assert(data[7] == 1, "Bit 7 (MSB) of -2 should be 1")
}

// ==========================================
// 2. Slicing (Descending Order: MSB..LSB)
// ==========================================

sim TestSlicingByte {
    wire data: u16 = 0xABCD
    
    wire high_byte: u8 = data[15..8]
    wire low_byte: u8 = data[7..0]
    
    assert(high_byte == 0xAB, "Upper byte slice should be 0xAB")
    assert(low_byte == 0xCD, "Lower byte slice should be 0xCD")
}

sim TestSlicingNibble {
    wire data: u8 = 0x4F 
    
    wire high_nibble: u4 = data[7..4]
    wire low_nibble: u4 = data[3..0]
    
    assert(high_nibble == 4, "Upper nibble should be 4")
    assert(low_nibble == 15, "Lower nibble should be 15 (0xF)")
}

sim TestSlicingArbitrary {
    wire data: u8 = 0b1101_0100
    
    wire mid: u4 = data[5..2]
    assert(mid == 5, "Middle slice [5..2] should be 5")
}

// ==========================================
// 3. Concatenation (Using Intrinsic `concat`)
// ==========================================

sim TestConcatenationBasic {
    wire high: u8 = 0xDE
    wire low: u8 = 0xAD
    
    // Combine two u8s into a u16 using the intrinsic function
    wire combined: u16
    combined := concat(high, low)
    
    assert(combined == 0xDEAD, "Concatenation should combine to 0xDEAD")
}

sim TestConcatenationMultiple {
    wire a: u4 = 0xA
    wire b: u4 = 0xB
    wire c: u4 = 0xC
    wire d: u4 = 0xD
    
    // concat can accept a variadic number of arguments
    wire combined: u16 = concat(a, b, c, d)
    assert(combined == 0xABCD, "Concatenating four u4s should form 0xABCD")
}

sim TestConcatenationWithLiterals {
    wire low: u2 = 0b11
    
    wire combined: u8 = concat(0xA as u4, low as u4)
    assert(combined == 0xA3, "Concatenation with casted literal should work")
}

// ==========================================
// 4. Combined Slicing and Concatenation
// ==========================================

sim TestEndianSwap {
    wire data: u16 = 0x1234
    
    // Swap the upper and lower bytes
    wire swapped: u16 = concat(data[7..0], data[15..8])
    assert(swapped == 0x3412, "Swapping bytes using slicing and concatenation")
}

// ==========================================
// 5. Compiler Error Documentation (Commented)
// ==========================================
/*
sim TestInvalidSliceAscending {
    wire data: u8 = 0xFF
    // ERROR: Ranges must be descending. [0..7] is explicitly invalid. 
    wire bad: u8 = data[0..7] 
}
*/

==== C:\Users\Matt\Projects\vctx\vctx-examples\operators\bitwise_not_working.vctx ====
sim TestBitwiseNotUnsigned {
    wire z: u8 = 0
    wire x: u8 = 0b10101010 // 170
    
    // ~0 in u8 is 255 (0xFF)
    assert(~z == 255, "Bitwise NOT of 0u8 is 255")
    
    // ~10101010 is 01010101 (85)
    assert(~x == 85,  "Bitwise NOT of 170 is 85")
}

sim TestBitwiseNotSigned {
    wire z: s8 = 0
    
    // ~0 in two's complement is -1
    assert(~z == -1, "Bitwise NOT of 0s8 is -1")
}

==== C:\Users\Matt\Projects\vctx\vctx-examples\operators\bitwise_not.vctx ====

sim TestBitwiseNotSigned2 {
    wire x: s8 = 1

    wire z: s8 = ~x

    assert(z == -2, "Bitwise NOT of 1 is -2")
}

==== C:\Users\Matt\Projects\vctx\vctx-examples\operators\casting.vctx ====
// ==========================================
// 1. Unsigned Width Conversions
// ==========================================

sim TestCast_Unsigned_Truncation {
    // Downcasting should strip the upper bits
    wire a: u16 = 0xABCD
    wire z: u8 = a as u8
    assert(z == 0xCD, "Truncating u16 (0xABCD) to u8 keeps only the lower 8 bits (0xCD)")
    
    wire b: u8 = 0b1010_1111
    wire y: u4 = b as u4
    assert(y == 0b1111, "Truncating u8 to u4 keeps lower nibble")
}

sim TestCast_Unsigned_Extension {
    // Upcasting unsigned should zero-extend
    wire a: u8 = 0xAB
    wire z: u16 = a as u16
    assert(z == 0x00AB, "Casting u8 to u16 pads the upper bits with zeros")
}

// ==========================================
// 2. Signed Width Conversions
// ==========================================

sim TestCast_Signed_Truncation {
    // Downcasting signed should still just strip upper bits
    wire a: s16 = 257       // 0x0101
    wire z: s8 = a as s8    // 0x01
    assert(z == 1, "Truncating s16 (257) to s8 becomes 1")

    wire b: s16 = -255      // 0xFF01
    wire y: s8 = b as s8    // 0x01
    assert(y == 1, "Truncating s16 (-255) to s8 becomes 1")
}

sim TestCast_Signed_Extension {
    // Upcasting signed MUST sign-extend (copy the MSB)
    wire positive: s8 = 5
    wire z_pos: s16 = positive as s16
    assert(z_pos == 5, "Positive s8 extends with zeros to s16")

    wire negative: s8 = -5
    wire z_neg: s16 = negative as s16
    assert(z_neg == -5, "Negative s8 extends with ones to keep value -5 in s16")
}

// ==========================================
// 3. Signed/Unsigned Reinterpretation
// ==========================================

sim TestCast_Signed_To_Unsigned {
    // Same width, just interpreting the bits differently
    wire a: s8 = -1
    wire z: u8 = a as u8
    assert(z == 255, "Casting s8 -1 to u8 reinterprets bits (11111111) as 255")
    
    wire b: s8 = -128
    wire y: u8 = b as u8
    assert(y == 128, "Casting s8 -128 to u8 reinterprets bits (10000000) as 128")
}

sim TestCast_Unsigned_To_Signed {
    wire a: u8 = 255
    wire z: s8 = a as s8
    assert(z == -1, "Casting u8 255 to s8 reinterprets bits (11111111) as -1")

    wire b: u8 = 128
    wire y: s8 = b as s8
    assert(y == -128, "Casting u8 128 to s8 reinterprets bits (10000000) as -128")
}

// ==========================================
// 4. Mathematical Wrapping (Overflow/Underflow)
// ==========================================

sim TestCast_Math_Unsigned_Wrap {
    wire zero: u8 = 0
    wire max: u8 = 255

    // Underflow
    wire under: u8 = (zero - 1) as u8
    assert(under == 255, "0 - 1 cast to u8 wraps to 255")

    // Overflow
    wire over: u8 = (max + 1) as u8
    assert(over == 0, "255 + 1 cast to u8 wraps to 0")
}

sim TestCast_Math_Signed_Wrap {
    wire max: s8 = 127
    wire min: s8 = -128

    // Overflow
    wire over: s8 = (max + 1) as s8
    assert(over == -128, "127 + 1 cast to s8 wraps to -128 (0x7F + 1 = 0x80)")

    // Underflow
    wire under: s8 = (min - 1) as s8
    assert(under == 127, "-128 - 1 cast to s8 wraps to 127 (0x80 - 1 = 0x7F)")
}

// ==========================================
// 5. Boolean Conversions
// ==========================================

sim TestCast_Boolean_Interop {
    wire bit_high: u1 = 1
    wire bit_low: u1 = 0
    
    // Integer to Bool
    wire is_true: bool = bit_high as bool
    wire is_false: bool = bit_low as bool
    assert(is_true == true, "u1 '1' casts to boolean true")
    assert(is_false == false, "u1 '0' casts to boolean false")

    // Bool to Integer
    wire b_true: bool = true
    wire b_false: bool = false
    wire num_one: u1 = b_true as u1
    wire num_zero: u1 = b_false as u1
    
    assert(num_one == 1, "boolean true casts to u1 '1'")
    assert(num_zero == 0, "boolean false casts to u1 '0'")
}

// ==========================================
// 6. Direct Literal Casting
// ==========================================

sim TestCast_Literals {
    wire a: u8 = -1 as u8
    assert(a == 255, "-1 literal directly cast to u8 is 255")

    wire b: u16 = 255 as u16
    assert(b == 0x00FF, "255 literal directly cast to u16 is 0x00FF")
}

==== C:\Users\Matt\Projects\vctx\vctx-examples\operators\casting1.vctx ====
sim TestCast_Unsigned_Truncation {
    // Downcasting should strip the upper bits
    wire a: u16 = 0xABCD
    wire z: u8 = a as u8
    assert(z == 0xCD, "Truncating u16 (0xABCD) to u8 keeps only the lower 8 bits (0xCD)")
}

==== C:\Users\Matt\Projects\vctx\vctx-examples\operators\logical_not.vctx ====
sim TestNotBool {
    wire t: bool = true
    wire f: bool = false
    
    assert(!t == false, "NOT true is false")
    assert(!f == true,  "NOT false is true")
}

sim TestNotUnsigned {
    // In VCTX/C, !0 is 1 (true), !non_zero is 0 (false)
    wire z: u8 = 0
    wire x: u8 = 42
    
    assert(!z == 1, "NOT 0 (unsigned) is 1")
    assert(!x == 0, "NOT 42 (unsigned) is 0")
}

sim TestNotSigned {
    wire z: s8 = 0
    wire x: s8 = -5
    
    assert(!z == 1, "NOT 0 (signed) is 1")
    assert(!x == 0, "NOT -5 (signed) is 0")
}

==== C:\Users\Matt\Projects\vctx\vctx-examples\operators\multiplication.vctx ====
sim TestMulUnsigned {
    wire a: u8 = 10
    wire b: u8 = 10
    
    assert(a * b == 100, "10 * 10 = 100")
}

sim TestMulSigned {
    wire a: s8 = 2
    wire b: s8 = -10
    
    assert(a * b == -20, "2 * -10 = -20")
    
    wire c: s8 = -2
    assert(c * b == 20, "-2 * -10 = 20")
}

==== C:\Users\Matt\Projects\vctx\vctx-examples\operators\subtraction.vctx ====
sim TestSubUnsigned {
    wire a: u8 = 20
    wire b: u8 = 10
    
    assert(a - b == 10, "20 - 10 = 10")
    
    // Test Underflow
    wire z: u8 = 0
    assert(z - 1 == -1, "mathematically, 0 - 1 = -1")
        
    assert((z - 1) as u8 == 255, "casting to u8 to wrap to 255")
}

sim TestSubSigned {
    wire a: s8 = 10
    wire b: s8 = 20
    
    assert(a - b == -10, "10 - 20 = -10")
    
    // Subtracting a negative (double negative)
    // 10 - (-5) = 15
    wire c: s8 = -5
    assert(a - c == 15, "10 - (-5) = 15")
}

